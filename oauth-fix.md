# OAuth Implementation Fix Plan

## Executive Summary

PR #36 implemented a full OAuth 2.0 server with PKCE flow, callback server, and authorization code exchange. However, for Claude (and likely other providers), we only need to capture and store long-lived session tokens. This document outlines the plan to simplify the OAuth implementation while keeping the correct storage infrastructure.

## Background & Analysis

### Current Situation
- **What PR #36 Added**: Full OAuth server on port 3737 with PKCE, callback handling, provider configs
- **What We Actually Need**: Simple token import for Claude's `sk-ant-oat01-` session tokens
- **Token Characteristics**:
  - Claude tokens are OAuth access tokens (prefix: `sk-ant-oat01-`)
  - Valid for 1 year (unusual for OAuth, but correct for Claude CLI)
  - Cannot be refreshed (they're session keys, not traditional OAuth)
  - Generated by `claude setup-token` command

### Storage Architecture Analysis

**Current Infrastructure (Keep):**
- `oauth_tokens` table is correctly designed for OAuth tokens
- Encryption via ChaCha20-Poly1305 AEAD (same as API keys)
- Expiration tracking (perfect for 1-year Claude tokens)
- Metadata fields for subscription type and account email

**Unnecessary Complexity (Remove):**
- `oauth_providers` table (OAuth server configuration)
- OAuth callback server (port 3737)
- PKCE implementation
- Authorization code exchange
- Token refresh logic

## Implementation Plan

### Phase 1: Database Schema Changes

#### 1.1 Modify `packages/storage/migrations/001_initial_schema.sql`

**REMOVE lines 728-740:**
```sql
-- OAuth Provider Configurations
CREATE TABLE oauth_providers (
    provider TEXT PRIMARY KEY CHECK (provider IN ('claude', 'openai', 'google', 'xai')),
    client_id TEXT NOT NULL,
    client_secret TEXT, -- Encrypted, if needed
    auth_url TEXT NOT NULL,
    token_url TEXT NOT NULL,
    redirect_uri TEXT NOT NULL,
    scopes TEXT NOT NULL, -- Space-separated
    enabled BOOLEAN DEFAULT 1,
    created_at INTEGER NOT NULL DEFAULT (unixepoch()),
    updated_at INTEGER NOT NULL DEFAULT (unixepoch())
);
```

**KEEP lines 709-726 (oauth_tokens table) AS-IS** - it's correctly designed

**REMOVE lines 744-745:**
```sql
-- OAuth indexes
CREATE INDEX idx_oauth_tokens_user ON oauth_tokens(user_id);
CREATE INDEX idx_oauth_tokens_provider ON oauth_tokens(provider);
CREATE INDEX idx_oauth_tokens_expires ON oauth_tokens(expires_at);
```

**ADD back the indexes with correct line numbers:**
```sql
-- OAuth token indexes
CREATE INDEX idx_oauth_tokens_user ON oauth_tokens(user_id);
CREATE INDEX idx_oauth_tokens_provider ON oauth_tokens(provider);
CREATE INDEX idx_oauth_tokens_expires ON oauth_tokens(expires_at);
```

#### 1.2 Modify `packages/storage/migrations/001_initial_schema.down.sql`

**REMOVE line 69:**
```sql
DROP TABLE IF EXISTS oauth_providers;
```

### Phase 2: Remove OAuth Server Code

#### 2.1 Files to DELETE Completely

| File | Lines | Purpose | Why Remove |
|------|-------|---------|------------|
| `packages/auth/src/oauth/server.rs` | 258 | OAuth callback server on port 3737 | No OAuth callbacks needed |
| `packages/auth/src/oauth/pkce.rs` | 128 | PKCE code challenge/verifier | No authorization flow |
| `packages/auth/src/oauth/provider.rs` | 146 | OAuth provider configurations | No OAuth endpoints |

#### 2.2 Simplify `packages/auth/src/oauth/manager.rs`

**REMOVE these methods:**
- `authenticate()` (lines 61-155)
- `refresh_token()` (lines 190-291)
- `build_auth_url()` (lines 330-350)
- `exchange_code_for_token()` (lines 352-390)
- `detect_subscription_type()` (lines 392-399)
- `get_account_email()` (lines 401-408)
- `default_provider_config()` (lines 410-426)

**ADD new method:**
```rust
/// Import a token directly without OAuth flow (for Claude session keys)
pub async fn import_token(&self, token: OAuthToken) -> AuthResult<()> {
    info!("Importing {} token for user {}", token.provider, token.user_id);

    // Validate token format
    if token.provider == "claude" && !token.access_token.starts_with("sk-ant-") {
        return Err(AuthError::InvalidToken(
            "Claude tokens should start with 'sk-ant-'".into()
        ));
    }

    // Store encrypted token
    self.storage.store_token(&token).await?;

    info!("Successfully imported {} token", token.provider);
    Ok(())
}
```

#### 2.3 Simplify `packages/auth/src/oauth/storage.rs`

**REMOVE these methods:**
- `store_provider_config()` (lines 181-218)
- `get_provider_config()` (lines 220-262)

**KEEP all token storage methods** - they work perfectly

#### 2.4 Update `packages/auth/src/oauth/types.rs`

**REMOVE these structs:**
- `OAuthProviderConfig`
- `PkceChallenge`
- `OAuthState`
- `TokenExchangeRequest`
- `TokenResponse`
- `RefreshTokenRequest`

**KEEP:**
- `OAuthToken` struct (it's perfect for our needs)
- `OAuthProvider` enum
- `ProviderStatus` struct

### Phase 3: Update CLI Commands

#### 3.1 Modify `packages/cli/src/bin/cli/auth.rs`

**Replace the entire `login_command()` function:**

```rust
async fn login_command(provider_str: &str, file: Option<&str>) -> Result<(), String> {
    let provider = parse_provider(provider_str)?;

    match provider {
        Provider::Claude => {
            if let Some(file_path) = file {
                // Import from file
                import_claude_from_file(file_path).await
            } else {
                // Run claude setup-token and capture output
                import_claude_from_setup().await
            }
        }
        Provider::OpenAI | Provider::Google | Provider::XAI => {
            Err(format!(
                "{} OAuth not yet implemented. Please use API keys in Settings instead.",
                provider
            ))
        }
    }
}

async fn import_claude_from_setup() -> Result<(), String> {
    println!("ðŸ” Running 'claude setup-token' to generate authentication token...");
    println!("   This will open your browser for authentication.\n");

    // Run claude setup-token
    let output = Command::new("claude")
        .arg("setup-token")
        .stdin(Stdio::inherit())   // Allow browser interaction
        .stdout(Stdio::piped())    // Capture token output
        .stderr(Stdio::inherit())  // Show progress
        .output()
        .map_err(|e| {
            if e.kind() == std::io::ErrorKind::NotFound {
                "Claude CLI not found. Please install it first:\n  npm install -g @anthropic-ai/claude-code".to_string()
            } else {
                format!("Failed to run 'claude setup-token': {}", e)
            }
        })?;

    if !output.status.success() {
        return Err("claude setup-token failed. Please try again.".into());
    }

    // Extract token from output
    let stdout = String::from_utf8_lossy(&output.stdout);
    let token = extract_claude_token(&stdout)?;

    // Store in oauth_tokens table
    store_claude_token(&token).await?;

    println!("\nâœ… Claude authentication token imported successfully!");
    println!("   Token expires in 1 year.");

    show_encryption_warning().await;
    Ok(())
}

async fn import_claude_from_file(file_path: &str) -> Result<(), String> {
    println!("ðŸ“„ Importing Claude token from file: {}", file_path);

    let token = fs::read_to_string(file_path)
        .map_err(|e| format!("Failed to read file: {}", e))?
        .trim()
        .to_string();

    // Validate token format
    if !token.starts_with("sk-ant-oat01-") {
        return Err(
            "Invalid token format. Claude OAuth tokens should start with 'sk-ant-oat01-'.\n\
             If you have an API key (sk-ant-api03-), use Settings instead.".into()
        );
    }

    store_claude_token(&token).await?;

    println!("\nâœ… Claude authentication token imported successfully!");
    println!("   Token expires in 1 year.");

    show_encryption_warning().await;
    Ok(())
}

fn extract_claude_token(output: &str) -> Result<String, String> {
    // Look for token in output (appears after success message)
    for line in output.lines() {
        if line.starts_with("sk-ant-oat01-") {
            return Ok(line.trim().to_string());
        }
    }

    Err("Could not find token in command output. Please try again.".into())
}

async fn store_claude_token(token: &str) -> Result<(), String> {
    let manager = OAuthManager::new_default().await
        .map_err(|e| format!("Failed to initialize OAuth manager: {}", e))?;

    let oauth_token = OAuthToken {
        id: nanoid::nanoid!(),
        user_id: "default-user".to_string(),  // TODO: Implement user system
        provider: "claude".to_string(),
        access_token: token.to_string(),
        refresh_token: None,  // Claude tokens don't refresh
        expires_at: Utc::now().timestamp() + (365 * 24 * 60 * 60), // 1 year
        token_type: "Bearer".to_string(),
        scope: Some("model:claude account:read".to_string()),
        subscription_type: None,  // Could detect later via API
        account_email: None,      // Could detect later via API
    };

    manager.import_token(oauth_token).await
        .map_err(|e| format!("Failed to store token: {}", e))?;

    Ok(())
}
```

**Update AuthCommands enum (keep existing structure):**
```rust
pub enum AuthCommands {
    /// Authenticate with an AI provider
    Login {
        /// Provider to authenticate with (claude, openai, google, xai)
        provider: String,

        /// For Claude: Import token from file instead of running setup
        #[arg(long)]
        file: Option<String>,
    },

    /// Logout from a provider (removes stored tokens)
    Logout {
        /// Provider to logout from (claude, openai, google, xai, all)
        provider: String,
    },

    /// Show authentication status for all providers
    Status,

    /// Refresh authentication token for a provider
    Refresh {
        /// Provider to refresh
        provider: String,
    },
}
```

### Phase 4: Update Error Handling

Add clear error messages for:
- Claude CLI not installed
- Invalid token format
- OAuth vs API key confusion

Example in `refresh_command()`:
```rust
if provider == Provider::Claude {
    return Err(
        "Claude tokens cannot be refreshed. They expire after 1 year.\n\
         Please run 'orkee auth login claude' to generate a new token.".into()
    );
}
```

### Phase 5: Documentation Updates

#### 5.1 Update `claude-token.md`

**Fix terminology throughout:**
- Change "API key" â†’ "OAuth token" or "authentication token"
- Change "claude_api_key" â†’ "Claude OAuth token"
- Update command examples to use `orkee auth login claude`

**Add clarification section:**
```markdown
## Token Types Explained

Claude/Anthropic uses different token formats for different purposes:

- `sk-ant-oat01-...` = OAuth Access Token (what `claude setup-token` generates)
  - Used by: Claude Code CLI
  - Validity: 1 year
  - Storage: `oauth_tokens` table
  - Command: `orkee auth login claude`

- `sk-ant-api03-...` = API Key (traditional programmatic access)
  - Used by: Direct API calls
  - Validity: No expiration
  - Storage: `users.anthropic_api_key`
  - Command: Use Settings UI

- `sk-ant-ort01-...` = OAuth Refresh Token (not used by Claude CLI)
  - Not applicable for our use case
```

#### 5.2 Update help text in CLI

Make commands self-documenting about what they do:
```rust
/// Authenticate with an AI provider
///
/// For Claude: Runs 'claude setup-token' to generate a 1-year OAuth token.
/// For other providers: Not yet implemented (use API keys in Settings).
```

## Testing Plan

### 1. Test Token Import Flow

```bash
# Test 1: Auto-import via claude setup-token
orkee auth login claude
# Should: Open browser, complete auth, capture token, store encrypted

# Test 2: Import from file
echo "sk-ant-oat01-2-sDpwPgSadVYuL..." > /tmp/token.txt
orkee auth login claude --file /tmp/token.txt
# Should: Import and encrypt token

# Test 3: Invalid token format
echo "sk-ant-api03-wrongtype" > /tmp/bad.txt
orkee auth login claude --file /tmp/bad.txt
# Should: Error about wrong token type

# Test 4: Status check
orkee auth status
# Should: Show Claude as authenticated with expiration date
```

### 2. Verify Encryption

```bash
# Check token is encrypted in database
sqlite3 ~/.orkee/orkee.db "SELECT provider, length(access_token), substr(access_token, 1, 10) FROM oauth_tokens;"
# Should show: claude | [length>38] | [base64 gibberish]
```

### 3. Test Error Cases

```bash
# Missing Claude CLI
mv $(which claude) /tmp/claude.bak 2>/dev/null || true
orkee auth login claude
# Should: Error message about installing Claude CLI

# Expired token handling
orkee auth refresh claude
# Should: Error that Claude tokens can't be refreshed

# Logout
orkee auth logout claude
# Should: Remove token from database
```

## Migration Impact

### Breaking Changes
None - we're removing features that were never released.

### User Impact
- Positive: Simpler, more intuitive flow
- No migration needed: No existing users

### Code Reduction
| Component | Lines Removed | Lines Added | Net Change |
|-----------|--------------|-------------|------------|
| OAuth Server Files | ~532 | 0 | -532 |
| Manager Simplification | ~365 | ~150 | -215 |
| Storage Simplification | ~80 | 0 | -80 |
| Schema | ~20 | 0 | -20 |
| **Total** | **~997** | **~150** | **-847 lines** |

## Success Criteria

1. âœ… `orkee auth login claude` successfully imports tokens
2. âœ… Tokens are encrypted in database
3. âœ… Token expiration is tracked (1 year)
4. âœ… OAuth server code is removed
5. âœ… No regression in API key storage
6. âœ… Clear error messages guide users

## Timeline

1. **Step 1**: Update schema files (15 min)
2. **Step 2**: Delete OAuth server files (5 min)
3. **Step 3**: Simplify manager/storage (30 min)
4. **Step 4**: Update CLI commands (45 min)
5. **Step 5**: Test all flows (30 min)
6. **Step 6**: Update documentation (15 min)

**Total: ~2.5 hours**

## Conclusion

This plan simplifies the OAuth implementation from a full OAuth server to a simple token import system, reducing complexity by ~850 lines of code while maintaining all necessary functionality for Claude authentication. The approach correctly uses the `oauth_tokens` table for OAuth tokens while keeping API keys in the `users` table, maintaining proper semantic separation.